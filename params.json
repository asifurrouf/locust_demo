{
  "name": "Locust-demo",
  "tagline": "A demo showing how to use the Locust load testing tool",
  "body": "## I am Load Testing and You Can Too!\r\n###### A gentle introduction to Locust\r\n\r\n### What is Locust?\r\n\r\nFrom [locust.io](http://locust.io):\r\n> Locust is an easy-to-use, distributed, user load testing tool. Intended for load testing web sites (or other systems) and figuring out how many concurrent users a system can handle.\r\n\r\n### Why Locust?\r\n* Load testing is hard to do on small projects - Locust makes it way easier, and it's written for Python 2.7, which you already have on your machine (you don't have to mess around with the JDK). *Not currently python 3 compatible* (:snake: :three: :-1:)\r\n* Loose coupling of testing infrastructure with codebases (one set of tests can be used against multiple web services)\r\n* Equally good for testing HTTP and systems based on other protocols ([example](http://docs.locust.io/en/latest/testing-other-systems.html)), although Locust gives you more code for HTTP out of the box, but its measurement protocol is generic. All you have to do is implement the `Locust` interface, and you can use it to measure anything. That's pretty cool.\r\n* POPO Philosophy. Very little procedural code, and minimal boilerplate. Everything is a Python class or Dict.\r\n* Very scaleable - can run in a local mode on your machine or distributed mode with an arbitrary number of master and slave servers.\r\n* Efficient CLI or pretty Web UI for interpreting results. Take your pick.\r\n\r\n### Why NOT Locust?\r\n* Locust is not a replacement for unit and integration testing. It doesn't do much to help you trace errors beyond logging the HTTP response statuses and any messages in the body. It's a specialist tool.\r\n* Can be frustrating to implement complex API scenarios because there's little abstraction over the HTTP calls themselves in Locust's native interface.\r\n* Much better at testing RESTful than stateful APIs (you're not writing stateful APIs, right? It's 2016.).\r\n\r\n### Let's get set up\r\nLocust will interact with your existing application purely over http - which means it works equally well with any language. I've used locust primarily for testing PHP applications, but pick your poison.\r\n\r\n```sh\r\n         ~/git         $ mkdir locust && cd locust\r\n         ~/git/locust  $ git init\r\n         ~/git/locust  $ mkvirtualenv locust          # set up your venv\r\n(locust) ~/git/locust  $ pip install locustio\r\n(locust) ~/git/locust  $ pip install zmq              # Keep Locust from throwing warnings if it can't use pyZmq\r\n(locust) ~/git/locust  $ touch locustfile.py          # locust looks for this file to contain your test runner\r\n```\r\n\r\n### Making a locustfile.py\r\nA locustfile must minimally define two objects. A client class (HttpLocust), that manages interactions with the API and a TaskSet class that defines the types of behaviors to test against the API.\r\n\r\n*Note: You can use any file as the source of the locust behavior with the -f flag: `locust -f /tests/load_tests.py`*\r\n\r\n\r\nHere's an extremely simple example:\r\n```python\r\nfrom locust import TaskSet, task, HttpLocust\r\n\r\nclass ApiClientBehavior(TaskSet):\r\n    \"\"\"\r\n    The @task decorator declares a locust task.\r\n    The argument passed the task decorator determines\r\n    the relative frequency with which the task\r\n    will be spawned within a swarm. For example\r\n    a task with a relative frequency of 1 will be\r\n    spawned half as often as a task with a \r\n    relative frequency of 2.\r\n    \"\"\"\r\n    @task(1)\r\n    def get_a_random_response(self):\r\n        # any call to locustio.TaskSet.get creates a \r\n        # response that will be logged in the load\r\n        # testing report\r\n        self.client.get(\"/random\",\r\n        \r\n        # name will give you a name that groups\r\n        # all calls from this method in the same\r\n        # report row, even if the URI is being\r\n        # randomly or procedurally generated\r\n        name='A Random HTTP Status',\r\n        \r\n        # Headers is just a Dict(). Everything\r\n        # in locust is a POPO.\r\n        headers={\r\n            \"Accept\": \"application/json\"\r\n        })\r\n\r\n    @task(2)\r\n    def get_a_success_response(self):\r\n        self.client.get(\"/success\",\r\n        name='A 200 Status',\r\n        headers={\r\n            \"Accept\": \"application/json\"\r\n        })\r\n\r\nclass ApiClient(HttpLocust):\r\n    # taskset is just a POPO\r\n    task_set = ApiClientBehavior\r\n    \r\n    # How long should a task wait after the batch\r\n    # member is spawned before executing. This creates\r\n    # randomness in the traffic patterns rather than\r\n    # having every member of the batch try to execute \r\n    # at once.\r\n    min_wait = 1000\r\n    max_wait = 5000\r\n```\r\n\r\n### Running your tests\r\n\r\n#### On the command line\r\n```sh\r\n(locust) ~/git/locust  $ locust --no-web \\\r\n  --host=prism.wpd.bsd.net \\\r\n  --clients=5 \\\r\n  --hatch-rate=100 \\\r\n  --num-requests=1000\r\n\r\n[2016-03-25 09:29:45,892] bmd-mbp.local/INFO/locust.main: Starting Locust 0.7.3\r\n[2016-03-25 09:29:45,892] bmd-mbp.local/INFO/locust.runners: Hatching and swarming 5 clients at the rate 100 clients/s...\r\n...later...\r\n[2016-03-25 09:29:48,949] bmd-mbp.local/INFO/locust.runners: All locusts hatched: ApiClient: 5\r\n[2016-03-25 09:29:48,950] bmd-mbp.local/INFO/locust.runners: Resetting stats\r\n[2016-03-25 09:29:48,950] bmd-mbp.local/INFO/locust.runners: All locusts dead\r\n[2016-03-25 09:29:48,950] bmd-mbp.local/INFO/locust.main: Shutting down (exit code 0), bye.\r\n```\r\n\r\n**Explanation:**\r\n\r\n`--host` - the domain to receive the locust traffic. You can also define this directly in your `HttpLocust` class, although this flag will still override it.\r\n\r\n`--clients` - the number of concurrent clients to use (one of the knobs you can use to control the volume of traffic in your test) - this setting is more important in distributed tests than local tests, and will affect the peak attack rate of the swarm.\r\n\r\n`--hatch-rate=` - the number of Locusts to hatch per second (remember that a locust isn't necessarily executed when it hatches immediately - the `min_wait` and `max_wait` parameters control how long it will wait to execute its request.\r\n\r\n`--num-requests=` - the total number of requests to execute. An estimate for the duration of the attack can be derived as `(hatch-rate / num-requests) + max_wait` seconds.\r\n\r\n#### Using the web UI\r\n```sh\r\n(locust) ~/git/locust  $ locust\r\n[2016-03-25 10:18:42,742] bmd-mbp.local/INFO/locust.main: Starting web monitor at *:8089\r\n[2016-03-25 10:18:42,743] bmd-mbp.local/INFO/locust.main: Starting Locust 0.7.3\r\n````\r\n\r\nMeanwhile back at ~~the ranch~~ `localhost:8089`...\r\n![Locust Intro Screen](https://www.dropbox.com/s/f4vrfpimt9c0rdd/Screenshot%202016-03-25%2009.40.45.png?dl=1) \r\n\r\nOnce you specify a swarm size and hatch rate per second, you can watch the swarm go in real time, and then download results and logs direcly from the web UI:\r\n![Locust Results Screen](https://www.dropbox.com/s/je3h7e47wrth3sw/Screenshot%202016-03-28%2012.15.16.png?dl=1)\r\n\r\n### Challenges\r\n* Getting traffic distribution correct - especially if your app is going to be exposed to real world users, it's hard to know what a realistic usage pattern for your application will look like.\r\n* Ensuring sufficient coverage (Locust doesn't give you any kind of coverage reports, since it doesn't know the application) can be difficult for complex APIs\r\n\r\n### Useful Locust Tricks\r\n\r\n##### Check the overall distribution of tasks within your swarms \r\n```sh\r\n(locust) ~/git/locust $ locust --show-task-ratio-json 2>&1 | jq .\r\n{\r\n  \"per_class\": {\r\n    \"ApiClient\": {\r\n      \"tasks\": {\r\n        \"get_a_random_response\": {\r\n          \"ratio\": 0.3333333333333333\r\n        },\r\n        \"get_a_success_response\": {\r\n          \"ratio\": 0.6666666666666666\r\n        }\r\n      },\r\n      \"ratio\": 1\r\n    }\r\n  },\r\n  \"total\": {\r\n    \"ApiClient\": {\r\n      \"tasks\": {\r\n        \"get_a_random_response\": {\r\n          \"ratio\": 0.3333333333333333\r\n        },\r\n        \"get_a_success_response\": {\r\n          \"ratio\": 0.6666666666666666\r\n        }\r\n      },\r\n      \"ratio\": 1\r\n    }\r\n  }\r\n}\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}